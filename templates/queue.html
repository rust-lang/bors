{% extends "base.html" %}

{% block title %}Bors queue - {{ repo_name }} {% if tree_state.is_closed() %} [TREECLOSED] {% endif %}{% endblock %}

{% block head %}
<link rel="stylesheet" href="https://cdn.datatables.net/2.3.4/css/dataTables.dataTables.min.css" />
<link rel="stylesheet" href="https://cdn.datatables.net/rowgroup/1.5.1/css/rowGroup.dataTables.min.css" />
<style>
    @keyframes barber-pole {
        /* This animation is used to make the status indicator next to
           pending pulls look like a barber poll. We do that with a
           diagonal linear gradient. CSS does not allow us to animate a
           gradient, so instead we make the indicator a little taller
           than shown, and then animate the whole thing upward. */
        from{
            transform: translate(0, 0);
        }
        to {
            /* The magic number 11.314 is sqrt(8^2 + 8^2), based on how
               far vertically it takes to repeat a 45 degree gradient
               that is 8 pixels long before it repeats. */
            transform: translate(0, -11.314px);
        }
    }
    main {
        max-width: 100rem;
        width: 100%;
        margin: 0 auto;
    }

    .table-wrapper {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
    }

    table {
        min-width: 100%;
        white-space: nowrap;

        --dt-row-stripe: 238, 238, 238;
        --dt-row-stripe-alpha: 255;
    }

    table th,
    table td {
        padding: 0.5rem;
    }

    th.select-checkbox,
    td.select-checkbox {
        width: 2.5rem;
    }
    table.dataTable > tbody > tr > td.status {
        position: relative;
        overflow: hidden;
        padding-left: 16px;
        white-space: nowrap;
    }
    td.status:before {
        content: " ";
        position: absolute;
        display: block;
        left: 6px;
        width: 6px;
        top: 0;
        bottom: 0;
    }
    td.status[data-status="pending"]:before {
        /* Give the pending state a little bit of animation to make it
           clear that these items are the ones that are being tested
           right now. */
        bottom: -20px;
        background-color: #F0DE57;
        background-image: repeating-linear-gradient(135deg, #F0DE57 0, #F0DE57 4px, #FBEE97 4px, #FBEE97 8px, #F0DE57 0);
        animation: barber-pole 1s linear infinite;
    }

    #rollupModal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.5);
    }

    #rollupModalContent {
        background-color: white;
        margin: 15% auto;
        padding: 1rem;
        border: 1px solid black;
        max-width: 500px;
    }

</style>
{% endblock %}

{% block body %}
<main>
  <h1>
    Bors queue - <a href="{{ repo_url }}" target="_blank">{{ repo_name }}</a>
    {% if tree_state.is_closed() %}
    {% if let Some(comment_source) = tree_state.comment_source() %}
    {% if let Some(priority) = tree_state.priority() %}
    [<a href="{{ comment_source }}">TREECLOSED</a> below priority {{ priority }}]
    {% endif %}
    {% endif %}
    {% endif %}
  </h1>

  <p><a href="/help">Help page</a></p>

  <p>
    {{ stats.total_count }} total, {{ stats.in_queue_count }} in queue,
    {{ stats.failed_count }} failed, {{ stats.rolled_up_count }} rolled up
  </p>

  <div style="margin-bottom: 1rem;">
    <label for="groupBy">Group by: </label>
    <select id="groupBy">
      <option value="">None</option>
      <option value="status">Status</option>
      <option value="mergeable">Mergeable</option>
      <option value="author">Author</option>
      <option value="priority">Priority</option>
    </select>
    <button id="showRollupSelection" style="margin-left: 1rem;">Create rollup</button>
  </div>

  <div class="table-wrapper">
    <table id="table" class="stripe">
        <thead>
            <tr>
                <th class="select-checkbox"></th>
                <th>#</th>
                <th>Status</th>
                <th>Mergeable</th>
                <th>Title</th>
                <th>Author</th>
                <th>Assignees</th>
                <th>Approved by</th>
                <th>Priority</th>
                <th>Rollup</th>
            </tr>
        </thead>

        <tbody>
            {% for pr in prs %}
            <tr data-rollupable="{{ pr.is_rollupable() }}"
                data-preselected="{{ selected_rollup_prs.contains(pr.number.0 as u32) }}">
                <td class="select-checkbox"></td>
                <td data-pr-number="{{ pr.number.0 }}">
                    <a href="{{ repo_url }}/pull/{{ pr.number }}">{{ pr.number.0 }}</a>
                </td>
                {% let pending_build = crate::templates::get_pending_build(pr) %}
                <td class="status" data-status="{{ crate::templates::status_text(pr) }}"
                    {% if let Some(build) = pending_build %}
                    title="Started at {{ to_local_time(*build.created_at).format("%d.%m.%Y %H:%M:%S") }}"
                    data-created-at="{{ build.created_at.timestamp_millis() }}"
                    {% endif %}>

                    {% if let Some(try_build) = pr.try_build %}
                    <a href="../results/{{ repo_name }}/{{ pr.number }}">{{ crate::templates::status_text(pr) }}</a> (try)
                    {% else %}
                    {{ crate::templates::status_text(pr) }}
                    {% endif %}
                    <span class="elapsed-time-display"></span>
                </td>
                <td>
                    {% match pr.mergeable_state %}
                    {% when Mergeable %}
                    yes
                    {% when HasConflicts %}
                    no
                    {% when Unknown %}
                    {% endmatch %}
                </td>
                <td>{{ pr.title }}</td>
                <td>{{ pr.author }}</td>
                <td>{{ pr.assignees|join(", ") }}</td>
                <td>
                    {% if let Some(approver) = pr.approver() %}
                    {{ approver }}
                    {% endif %}
                </td>
                <td>{{ pr.priority.unwrap_or(0) }}</td>
                <td>
                    {% if let Some(rollup) = pr.rollup %}
                    {{ rollup }}
                    {% endif %}
                </td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
  </div>

  <div style="text-align: center; margin-top: 1em;">
    <a href="https://github.com/rust-lang/bors">Contribute on GitHub</a>
  </div>

  <div id="rollupModal">
    <div id="rollupModalContent">
      <p id="rollupModalMessage"></p>
      <button id="rollupModalContinue" style="display: none;">Continue</button>
    </div>
  </div>
</main>

<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<script src="https://cdn.datatables.net/2.3.4/js/dataTables.min.js"></script>
<script src="https://cdn.datatables.net/rowgroup/1.6.0/js/dataTables.rowGroup.min.js"></script>
<script src="https://cdn.datatables.net/select/3.1.3/js/dataTables.select.min.js"></script>

<script>
    const getDataStatusFromCell = (cell) => cell?.dataset?.status || "";
    const interactiveSelector = "a, button, input, label, select, textarea";

    function initializeTable(groupByColumnName) {
        let config = {
            paging: false,
            info: false,
            columns: [
                { name: "select", orderable: false, className: "select-checkbox" },
                { name: "number" },
                { name: "status" },
                { name: "mergeable" },
                { name: "title" },
                { name: "author" },
                { name: "assignees" },
                { name: "approved_by" },
                { name: "priority" },
                { name: "rollup" }
            ],
            columnDefs: [
                {
                    targets: "select:name",
                    render: DataTable.render.select()
                },
                {
                    targets: "status:name",
                    render: (data, type, row, meta) => {
                        if (type === "display") {
                            return data;
                        }

                        // Use data-status for everything else
                        if (meta && meta.settings && meta.row !== undefined) {
                            let rowNode = meta.settings.aoData[meta.row]?.nTr;
                            if (rowNode) {
                                return getDataStatusFromCell(rowNode.cells[meta.col]);
                            }
                        }

                        return data;
                    }
                }
            ],
            order: [],
            select: {
                style: "multi",
                selector: "td.select-checkbox",
                headerCheckbox: true,
                selectable: (rowData, tr, index) => {
                    return tr && tr.dataset && tr.dataset.rollupable === "true";
                }
            },
            initComplete: function() {
              // Pre-select nodes based on query parameter
              this.api().rows((idx, data, node) => {
                return node.dataset.preselected === "true";
              }).select();
            }
        };

        if (groupByColumnName) {
            const colIndex = table.column(groupByColumnName + ":name").index()
            config.order = [[colIndex, "asc"]];
            config.rowGroup = {
                dataSrc: groupByColumnName === "status"
                    ? (row, type) => {
                        let table = $("#table").DataTable();
                        let statusHtml = row[colIndex];

                        // Find the corresponding DOM cell to get data-status attribute
                        let tableRows = document.querySelectorAll("#table tbody tr");
                        for (let tableRow of tableRows) {
                            let statusCell = tableRow.cells[colIndex];
                            if (statusCell && statusCell.innerHTML.trim() === statusHtml.trim()) {
                                return getDataStatusFromCell(statusCell);
                            }
                        }

                        // Fallback to HTML content
                        return statusHtml;
                    }
                    : colIndex
            };
        }
        return new DataTable("#table", config);
    }

    function bindRowClick(tableInstance) {
        const tbody = document.querySelector("#table tbody");
        if (!tbody) {
            return () => {};
        }

        const handler = (event) => {
            // Ignore clicks on checkbox - let checkbox handle it
            if (event.target.closest("td.select-checkbox")) {
                return;
            }

            // Ignore clicks on interactive elements
            if (event.target.closest(interactiveSelector)) {
                return;
            }

            const rowElement = event.target.closest("tr");
            if (!rowElement) {
                return;
            }

            const rowApi = tableInstance.row(rowElement);
            if (!rowApi.any()) {
                return;
            }

            if (rowApi.selected()) {
                rowApi.deselect();
            } else {
                rowApi.select();
            }
        };

        tbody.addEventListener("click", handler);
        return () => tbody.removeEventListener("click", handler);
    }

    let table = initializeTable(null);
    let detachRowClick = bindRowClick(table);

    // Handle group by dropdown changes
    document.getElementById("groupBy").addEventListener("change", function() {
        let groupByColumnName = this.value === "" ? null : this.value;
        table.destroy();
        detachRowClick();
        table = initializeTable(groupByColumnName);
        detachRowClick = bindRowClick(table);
    });

    const createRollupButton = document.getElementById("showRollupSelection")
    const modal = document.getElementById("rollupModal");
    const modalMessage = document.getElementById("rollupModalMessage");
    const rollupContinueButton = document.getElementById("rollupModalContinue");

    // Handle modal outside click
    window.addEventListener("click", (event) => {
        if (event.target === modal) {
            modal.style.display = "none";
            rollupContinueButton.style.display = "none";
        }
    });

    createRollupButton.addEventListener("click", () => {
        {% if oauth_client_id.is_none() %}
        alert("Both CLIENT_ID and CLIENT_SECRET must be set to enabled OAuth.");
        return;
        {% endif %}

        const selectedRows = table.rows({ selected: true }).nodes().toArray();
        let message;

        if (selectedRows.length === 0) {
            message = "No PRs selected for rollup.";
            rollupContinueButton.style.display = "none";
        } else {
            message = `You've selected <strong>${selectedRows.length} PR(s)</strong> to be included in this rollup.<br><br>
            A rollup is useful for shortening the queue, but jumping the queue is unfair to older PRs who have waited too long.<br><br>
            When creating a real rollup, see the <a href="https://forge.rust-lang.org/release/rollups.html" target="_blank">instructions</a> for reference.`;
            rollupContinueButton.style.display = "inline-block";
        }

        modalMessage.innerHTML = message;
        modal.style.display = "block";
    });

    {% if let Some(client_id) = oauth_client_id %}
    rollupContinueButton.addEventListener("click", () => {
        const scopes = ["public_repo", "workflow"];

        // Gather PR numbers
        let selectedRows = table.rows({ selected: true }).nodes().toArray();
        let nums = selectedRows
            .map(row => {
                let numberCell = row.cells[1];
                return numberCell?.dataset?.prNumber ? parseInt(numberCell.dataset.prNumber) : null;
            })
            .filter(num => num !== null);

        let state = JSON.stringify({
            pr_nums: nums,
            repo_name: "{{ repo_name }}",
            repo_owner: "{{ repo_owner }}"
        });

        const oauthUrl = new URL("https://github.com/login/oauth/authorize");
        oauthUrl.searchParams.set("client_id", "{{ client_id }}");
        oauthUrl.searchParams.set("scope", scopes.join(","));
        oauthUrl.searchParams.set("state", state);

        window.location.href = oauthUrl.toString();
    });
    {% endif %}

    function formatElapsedTime(ms) {
        const totalSeconds = Math.floor(ms / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const remainingSeconds = totalSeconds % 3600;
        const minutes = Math.floor(remainingSeconds / 60);

        let output = '';
        if (hours > 0) {
            output += `${hours}h`;
        }

        if (minutes > 0) {
            if (output.length > 0) {
                output += ' ';
            }
            output += `${minutes}m`;
        }
        if (output.length > 0) {
            return ` (${output})`;
        }
        return '';
    }

    function updateElapsedTimes() {
        const now = Date.now();
        document.querySelectorAll('[data-created-at]').forEach(td => {
            const createdAtMs = parseInt(td.dataset.createdAt, 10);
            if (createdAtMs > 0) {
                const elapsedMs = now - createdAtMs;
                const formattedTime = formatElapsedTime(elapsedMs);
                let display = td.querySelector('.elapsed-time-display');
                display.textContent = formattedTime;
            }
        });
    }

    updateElapsedTimes();
    setInterval(updateElapsedTimes, 1000);
</script>
{% endblock %}
